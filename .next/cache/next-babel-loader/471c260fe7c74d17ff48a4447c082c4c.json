{"ast":null,"code":"import Moment from 'moment';\nimport * as MomentRange from 'moment-range';\nconst moment = MomentRange.extendMoment(Moment);\nexport const getValidValue = value => value && value.trim() !== \"\" && value.trim() !== \"not found\" ? value : \"\";\nexport const getName = doctor => {\n  const {\n    basic\n  } = doctor;\n  if (!basic) return \"No Name\";\n  const {\n    name_prefix,\n    name,\n    credential\n  } = basic;\n  const nameVal = getValidValue(name);\n  const name_prefixVal = getValidValue(name_prefix);\n  const credentialVal = getValidValue(credential);\n  const wholeName = `${name_prefixVal} ${nameVal}  ${credentialVal}`;\n  if (wholeName.trim() === \"\") return \"No Name\";\n  return wholeName;\n};\nexport const getSlug = doctor => {\n  return doctor._id; // const {\n  //   basic\n  // } = doctor\n  // if (!basic)\n  //   return \"no-slug\"\n  // const {\n  //   name_prefix,\n  //   name,\n  //   credential\n  // } = basic\n  // var nameVal = getValidValue(name);\n  // nameVal = nameVal.replace(\" \", \"-\");\n  // const wholeName = `${nameVal}`\n  // if (wholeName.trim() === \"\")\n  //   return \"No Name\"\n  // return wholeName\n};\nexport const getAddress = doctor => {\n  const {\n    address\n  } = doctor;\n  if (!address) return \"\";\n  if (address.length < 1) return \"\";\n  const {\n    address_1,\n    address_2,\n    city,\n    country_name,\n    postal_code,\n    telephone_number\n  } = address[0];\n  const address_1Val = getValidValue(address_1);\n  const address_2Val = getValidValue(address_2);\n  const cityVal = getValidValue(city);\n  const country_nameVal = getValidValue(country_name);\n  const postal_codeVal = getValidValue(postal_code);\n  const telephone_numberVal = getValidValue(telephone_number);\n  const wholeAddress = [address_1Val, address_2Val, cityVal, country_nameVal, postal_codeVal, telephone_numberVal].filter(el => el && el.trim() !== \"\").join(\", \");\n  return wholeAddress;\n};\nexport const getTaxonomy = doctor => {\n  const {\n    taxonomies\n  } = doctor;\n  if (!taxonomies) return \"\";\n  if (taxonomies.length < 1) return \"\";\n  const {\n    desc\n  } = taxonomies[0];\n  return getValidValue(desc);\n};\nexport const removeDublecatVale = (originalArray, key) => {\n  var newArray = [];\n  var lookupObject = {};\n\n  for (var i in originalArray) {\n    lookupObject[originalArray[i][key]] = originalArray[i];\n  }\n\n  for (i in lookupObject) {\n    newArray.push(lookupObject[i]);\n  }\n\n  return newArray;\n};\nexport const getAppointmentsOfDate = (appointments = [], date) => appointments.filter(el => moment(el.bookedFor).isSame(date, \"day\"));\nexport const getDoctorTimeLine = ({\n  timeSlot,\n  allAppointments,\n  date\n}) => {\n  const appointment = getAppointmentsOfDate(allAppointments, date);\n\n  if (appointment.length < 1) {\n    return {\n      status: false\n    };\n  }\n\n  const moments = appointment.map(el => moment(el.bookedFor));\n  const max = moment.max(moments).format(\"HH\");\n  const min = moment.min(moments).format(\"HH\");\n  const day_start = moment().startOf('day').hours(parseInt(min));\n  const day_end = moment().startOf('day').hours(parseInt(max));\n  const day = moment.range(day_start, day_end); // console.clear()\n  // console.log({\n  //   day: Array.from(day.by('minutes', {step: timeSlot})).map(el => el.format(\"HH:mm\"))\n  // })\n\n  return {\n    status: true,\n    dates: Array.from(day.by('minutes', {\n      step: timeSlot\n    }))\n  };\n};","map":{"version":3,"sources":["/Users/akshataggarwal/Documents/Coding Files/webd projects/missnew front/services/helpers/DoctorHelpers.js"],"names":["Moment","MomentRange","moment","extendMoment","getValidValue","value","trim","getName","doctor","basic","name_prefix","name","credential","nameVal","name_prefixVal","credentialVal","wholeName","getSlug","_id","getAddress","address","length","address_1","address_2","city","country_name","postal_code","telephone_number","address_1Val","address_2Val","cityVal","country_nameVal","postal_codeVal","telephone_numberVal","wholeAddress","filter","el","join","getTaxonomy","taxonomies","desc","removeDublecatVale","originalArray","key","newArray","lookupObject","i","push","getAppointmentsOfDate","appointments","date","bookedFor","isSame","getDoctorTimeLine","timeSlot","allAppointments","appointment","status","moments","map","max","format","min","day_start","startOf","hours","parseInt","day_end","day","range","dates","Array","from","by","step"],"mappings":"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","sourcesContent":["import Moment from 'moment'\nimport * as MomentRange from 'moment-range'\nconst moment = MomentRange.extendMoment(Moment);\nexport const getValidValue = value => (value && value.trim() !== \"\" && value.trim() !== \"not found\") ? value : \"\"\n\nexport const getName = doctor => {\n  const {\n    basic\n  } = doctor\n  if (!basic)\n    return \"No Name\"\n\n  const {\n    name_prefix,\n    name,\n    credential\n  } = basic\n  const nameVal = getValidValue(name)\n  const name_prefixVal = getValidValue(name_prefix)\n  const credentialVal = getValidValue(credential)\n\n  const wholeName = `${name_prefixVal} ${nameVal}  ${credentialVal}`\n\n  if (wholeName.trim() === \"\")\n    return \"No Name\"\n\n  return wholeName\n}\n\nexport const getSlug = doctor => {\n  return doctor._id\n  // const {\n  //   basic\n  // } = doctor\n  // if (!basic)\n  //   return \"no-slug\"\n\n  // const {\n  //   name_prefix,\n  //   name,\n  //   credential\n  // } = basic\n  // var nameVal = getValidValue(name);\n  // nameVal = nameVal.replace(\" \", \"-\");\n  // const wholeName = `${nameVal}`\n  \n  // if (wholeName.trim() === \"\")\n  //   return \"No Name\"\n\n  // return wholeName\n}\n\n\n\nexport const getAddress = doctor => {\n  const {\n    address\n  } = doctor\n  if (!address)\n    return \"\"\n  if (address.length < 1)\n    return \"\"\n\n  const {\n    address_1,\n    address_2,\n    city,\n    country_name,\n    postal_code,\n    telephone_number\n  } = address[0]\n  const address_1Val = getValidValue(address_1)\n  const address_2Val = getValidValue(address_2)\n  const cityVal = getValidValue(city)\n  const country_nameVal = getValidValue(country_name)\n  const postal_codeVal = getValidValue(postal_code)\n  const telephone_numberVal = getValidValue(telephone_number)\n  const wholeAddress = [\n    address_1Val,\n    address_2Val,\n    cityVal,\n    country_nameVal,\n    postal_codeVal,\n    telephone_numberVal,\n  ].filter(el => (el && el.trim() !== \"\")).join(\", \")\n\n  return wholeAddress\n}\n\nexport const getTaxonomy = doctor => {\n  const {\n    taxonomies\n  } = doctor\n  if (!taxonomies )\n    return \"\"\n  if(taxonomies.length < 1)\n    return \"\"\n  const {\n    desc\n  } = taxonomies[0]\n  return getValidValue(desc)\n}\n\n\nexport const removeDublecatVale = (originalArray,key) =>{\n  var newArray = [];\n     var lookupObject  = {};\n     for(var i in originalArray) {\n        lookupObject[originalArray[i][key]] = originalArray[i];\n     }\n\n     for(i in lookupObject) {\n         newArray.push(lookupObject[i]);\n     }\n      return newArray;\n}\n\nexport const getAppointmentsOfDate = (appointments = [], date)=> \n  appointments.filter(el => moment(el.bookedFor).isSame(date, \"day\"))\n\nexport const getDoctorTimeLine = ({\n  timeSlot,\n  allAppointments,\n  date\n}) => {\n  const appointment = getAppointmentsOfDate(allAppointments, date)\n  if(appointment.length < 1){\n    return {\n      status: false\n    }\n  }\n  const moments = appointment.map(el => moment(el.bookedFor))\n  const max = moment.max(moments).format(\"HH\")\n  const min = moment.min(moments).format(\"HH\")\n  const day_start = moment().startOf('day').hours(parseInt(min))\n  const day_end = moment().startOf('day').hours(parseInt(max))\n  const day = moment.range(day_start, day_end)\n  // console.clear()\n  // console.log({\n  //   day: Array.from(day.by('minutes', {step: timeSlot})).map(el => el.format(\"HH:mm\"))\n  // })\n  return {\n    status: true,\n    dates: Array.from(day.by('minutes', {step: timeSlot}))\n  }\n}"]},"metadata":{},"sourceType":"module"}